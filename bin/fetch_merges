#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/inline'

gemfile do
  source 'http://rubygems.org'
  gem 'activerecord'
  gem 'ruby-vips'
  gem 'sqlite3'
  gem 'pry'
  gem 'grit'
  gem 'kramdown'
  gem 'kramdown-parser-gfm'
  gem 'rugged'
  gem 'rouge'
end

require 'json'

MergeItem = Struct.new(:message, :project, :date_merged, :author, :sha, :pr, :merge_sha, :html, keyword_init: true)

$rails_checkout = './rails'

class MergeFinder
  attr_reader :branch

  def initialize(changelog_file, branch = 'main')
    @branch = branch
    @changelog_file = changelog_file
    @gem = @changelog_file.split('/')[0]
  end

  def find
    lines = repo.blame("./#{@changelog_file}", branch).lines.reject { |l| l.line['Please check ['] }
    merges = lines.slice_before { |i| i.line[/^\*/] }

    merges.map do |merge|
      commit = merge.first.commit
      merge_commit = find_merge_commit(commit.sha)

      MergeItem.new(
        message: message = merge.map(&:line).join("\n").force_encoding('UTF-8').strip,
        html: md(message),
        project: @gem,
        author: merge.first.commit.author.name.force_encoding(Encoding::UTF_8),
        sha: merge.first.commit.id,
        merge_sha: merge_commit.oid,
        pr: merge_commit.message[/#(\d+)/, 1],
        date_merged: merge_commit.time.to_i * 1000
      )
    end
  end

  private

  def md(text)
    text = text.
      # remove the leading * in first line
      gsub(/\A\* /, '').strip.
      # remove global intendation
      lines.map { |i| i.sub(/^ {2,4}/, '') }.join
    Kramdown::Document.new(text,
                           syntax_highlighter: 'rouge',
                           input: 'GFM').to_html
  end

  def find_merge_commit(sha)
    # Simple bash:
    # merge_commit = `cd #{$rails_checkout} && (git rev-list #{sha}..#{branch}
    # --ancestry-path | cat -n; git rev-list #{sha}..#{branch} --first-parent |
    # cat -n) | sort -k2 -s |uniq -f1 -d | sort -n | tail -1 | cut -f2`&.strip

    # using Grit:
    ancestry_path = repo.git.log({}, ["#{sha}..#{branch}", '--merges', '--ancestry-path', '--oneline']).lines.map { |i| i.split.first }
    first_parent = repo.git.log({}, ["#{sha}..#{branch}", '--merges', '--first-parent', '--oneline']).lines.map { |i| i.split.first }
    merge_commit = (ancestry_path & first_parent).last
    rugged_repo.lookup(merge_commit)
  end

  def repo
    @repo ||= Grit::Repo.new($rails_checkout)
  end

  def rugged_repo
    @rugged_repo ||= Rugged::Repository.new($rails_checkout)
  end
end

merges = []

if ARGV[0]
  branch = ARGV[0]
else
  branch = 'main'
end
puts "Fetching merges for branch '#{branch}'"
puts "Rerun with #{__FILE__} <branch> to fetch merges for a different branch"
puts "e.g. #{__FILE__} 7-0-stable"

Dir['rails/*/CHANGELOG.md'].each do |changelog|
  puts "processing #{changelog}"
  b = if branch == 'main'
        branch
      else
        "origin/#{branch}"
      end
  merges += MergeFinder.new(changelog.sub('rails/', ''), b).find
end
fname = "src/_data/merges_#{branch}.json"
puts "Writing #{merges.length} merges to file: #{fname}"
File.write(fname, JSON.pretty_generate(merges.map(&:to_h)))
